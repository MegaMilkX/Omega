#include "hl2_vtf.hpp"

#include <assert.h>
#include <stdio.h>
#include <unordered_map>
#include "log/log.hpp"

#define IDVTFHEADER_LE	(('\0'<<24)+('F'<<16)+('T'<<8)+'V')
#define IDVTFHEADER_BE	(('V'<<24)+('T'<<16)+('F'<<8)+'\0')

#define FREAD(BUFFER, SIZE, COUNT, FILE) \
if (fread(BUFFER, SIZE, COUNT, FILE) != COUNT) { \
    assert(false); \
    return false; \
}

#define ON_ERROR \
fclose(f); \
assert(false); \
return false;

#define VTF_VERSION_7_1 (uint64_t(7) | (uint64_t(1) << 32))
#define VTF_VERSION_7_2 (uint64_t(7) | (uint64_t(2) << 32))
#define VTF_VERSION_7_3 (uint64_t(7) | (uint64_t(3) << 32))
#define VTF_VERSION_7_4 (uint64_t(7) | (uint64_t(4) << 32))

enum IMAGE_FORMAT {
    IMAGE_FORMAT_NONE = -1,
    IMAGE_FORMAT_RGBA8888 = 0,
    IMAGE_FORMAT_ABGR8888,
    IMAGE_FORMAT_RGB888,
    IMAGE_FORMAT_BGR888,
    IMAGE_FORMAT_RGB565,
    IMAGE_FORMAT_I8,
    IMAGE_FORMAT_IA88,
    IMAGE_FORMAT_P8,
    IMAGE_FORMAT_A8,
    IMAGE_FORMAT_RGB888_BLUESCREEN,
    IMAGE_FORMAT_BGR888_BLUESCREEN,
    IMAGE_FORMAT_ARGB8888,
    IMAGE_FORMAT_BGRA8888,
    IMAGE_FORMAT_DXT1,
    IMAGE_FORMAT_DXT3,
    IMAGE_FORMAT_DXT5,
    IMAGE_FORMAT_BGRX8888,
    IMAGE_FORMAT_BGR565,
    IMAGE_FORMAT_BGRX5551,
    IMAGE_FORMAT_BGRA4444,
    IMAGE_FORMAT_DXT1_ONEBITALPHA,
    IMAGE_FORMAT_BGRA5551,
    IMAGE_FORMAT_UV88,
    IMAGE_FORMAT_UVWQ8888,
    IMAGE_FORMAT_RGBA16161616F,
    IMAGE_FORMAT_RGBA16161616,
    IMAGE_FORMAT_UVLX8888
};

static const char* imageFormatToString(IMAGE_FORMAT fmt) {
    switch (fmt) {    
    case IMAGE_FORMAT_NONE: return "IMAGE_FORMAT_NONE";
    case IMAGE_FORMAT_RGBA8888: return "IMAGE_FORMAT_RGBA8888";
    case IMAGE_FORMAT_ABGR8888: return "IMAGE_FORMAT_ABGR8888";
    case IMAGE_FORMAT_RGB888: return "IMAGE_FORMAT_RGB888";
    case IMAGE_FORMAT_BGR888: return "IMAGE_FORMAT_BGR888";
    case IMAGE_FORMAT_RGB565: return "IMAGE_FORMAT_RGB565";
    case IMAGE_FORMAT_I8: return "IMAGE_FORMAT_I8";
    case IMAGE_FORMAT_IA88: return "IMAGE_FORMAT_IA88";
    case IMAGE_FORMAT_P8: return "IMAGE_FORMAT_P8";
    case IMAGE_FORMAT_A8: return "IMAGE_FORMAT_A8";
    case IMAGE_FORMAT_RGB888_BLUESCREEN: return "IMAGE_FORMAT_RGB888_BLUESCREEN";
    case IMAGE_FORMAT_BGR888_BLUESCREEN: return "IMAGE_FORMAT_BGR888_BLUESCREEN";
    case IMAGE_FORMAT_ARGB8888: return "IMAGE_FORMAT_ARGB8888";
    case IMAGE_FORMAT_BGRA8888: return "IMAGE_FORMAT_BGRA8888";
    case IMAGE_FORMAT_DXT1: return "IMAGE_FORMAT_DXT1";
    case IMAGE_FORMAT_DXT3: return "IMAGE_FORMAT_DXT3";
    case IMAGE_FORMAT_DXT5: return "IMAGE_FORMAT_DXT5";
    case IMAGE_FORMAT_BGRX8888: return "IMAGE_FORMAT_BGRX8888";
    case IMAGE_FORMAT_BGR565: return "IMAGE_FORMAT_BGR565";
    case IMAGE_FORMAT_BGRX5551: return "IMAGE_FORMAT_BGRX5551";
    case IMAGE_FORMAT_BGRA4444: return "IMAGE_FORMAT_BGRA4444";
    case IMAGE_FORMAT_DXT1_ONEBITALPHA: return "IMAGE_FORMAT_DXT1_ONEBITALPHA";
    case IMAGE_FORMAT_BGRA5551: return "IMAGE_FORMAT_BGRA5551";
    case IMAGE_FORMAT_UV88: return "IMAGE_FORMAT_UV88";
    case IMAGE_FORMAT_UVWQ8888: return "IMAGE_FORMAT_UVWQ8888";
    case IMAGE_FORMAT_RGBA16161616F: return "IMAGE_FORMAT_RGBA16161616F";
    case IMAGE_FORMAT_RGBA16161616: return "IMAGE_FORMAT_RGBA16161616";
    case IMAGE_FORMAT_UVLX8888: return "IMAGE_FORMAT_UVLX8888";
    }
    return "UNKNOWN";
}

enum COMPILED_VTF_FLAGS
{
    // Flags from the *.txt config file
    TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
    TEXTUREFLAGS_TRILINEAR = 0x00000002,
    TEXTUREFLAGS_CLAMPS = 0x00000004,
    TEXTUREFLAGS_CLAMPT = 0x00000008,
    TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
    TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
    TEXTUREFLAGS_PWL_CORRECTED = 0x00000040,
    TEXTUREFLAGS_NORMAL = 0x00000080,
    TEXTUREFLAGS_NOMIP = 0x00000100,
    TEXTUREFLAGS_NOLOD = 0x00000200,
    TEXTUREFLAGS_ALL_MIPS = 0x00000400,
    TEXTUREFLAGS_PROCEDURAL = 0x00000800,

    // These are automatically generated by vtex from the texture data.
    TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
    TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,

    // Newer flags from the *.txt config file
    TEXTUREFLAGS_ENVMAP = 0x00004000,
    TEXTUREFLAGS_RENDERTARGET = 0x00008000,
    TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
    TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
    TEXTUREFLAGS_SINGLECOPY	= 0x00040000,
    TEXTUREFLAGS_PRE_SRGB = 0x00080000,

    TEXTUREFLAGS_UNUSED_00100000 = 0x00100000,
    TEXTUREFLAGS_UNUSED_00200000 = 0x00200000,
    TEXTUREFLAGS_UNUSED_00400000 = 0x00400000,

    TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,

    TEXTUREFLAGS_UNUSED_01000000 = 0x01000000,

    TEXTUREFLAGS_CLAMPU = 0x02000000,
    TEXTUREFLAGS_VERTEXTEXTURE = 0x04000000,
    TEXTUREFLAGS_SSBUMP = 0x08000000,

    TEXTUREFLAGS_UNUSED_10000000 = 0x10000000,

    TEXTUREFLAGS_BORDER = 0x20000000,

    TEXTUREFLAGS_UNUSED_40000000 = 0x40000000,
    TEXTUREFLAGS_UNUSED_80000000 = 0x80000000,
};

static const char* flagToString(uint32_t flag) {
    switch (flag) {
    case TEXTUREFLAGS_POINTSAMPLE: return "TEXTUREFLAGS_POINTSAMPLE";
    case TEXTUREFLAGS_TRILINEAR: return "TEXTUREFLAGS_TRILINEAR";
    case TEXTUREFLAGS_CLAMPS: return "TEXTUREFLAGS_CLAMPS";
    case TEXTUREFLAGS_CLAMPT: return "TEXTUREFLAGS_CLAMPT";
    case TEXTUREFLAGS_ANISOTROPIC: return "TEXTUREFLAGS_ANISOTROPIC";
    case TEXTUREFLAGS_HINT_DXT5: return "TEXTUREFLAGS_HINT_DXT5";
    case TEXTUREFLAGS_PWL_CORRECTED: return "TEXTUREFLAGS_PWL_CORRECTED";
    case TEXTUREFLAGS_NORMAL: return "TEXTUREFLAGS_NORMAL";
    case TEXTUREFLAGS_NOMIP: return "TEXTUREFLAGS_NOMIP";
    case TEXTUREFLAGS_NOLOD: return "TEXTUREFLAGS_NOLOD";
    case TEXTUREFLAGS_ALL_MIPS: return "TEXTUREFLAGS_ALL_MIPS";
    case TEXTUREFLAGS_PROCEDURAL: return "TEXTUREFLAGS_PROCEDURAL";
    case TEXTUREFLAGS_ONEBITALPHA: return "TEXTUREFLAGS_ONEBITALPHA";
    case TEXTUREFLAGS_EIGHTBITALPHA: return "TEXTUREFLAGS_EIGHTBITALPHA";
    case TEXTUREFLAGS_ENVMAP: return "TEXTUREFLAGS_ENVMAP";
    case TEXTUREFLAGS_RENDERTARGET: return "TEXTUREFLAGS_RENDERTARGET";
    case TEXTUREFLAGS_DEPTHRENDERTARGET: return "TEXTUREFLAGS_DEPTHRENDERTARGET";
    case TEXTUREFLAGS_NODEBUGOVERRIDE: return "TEXTUREFLAGS_NODEBUGOVERRIDE";
    case TEXTUREFLAGS_SINGLECOPY: return "TEXTUREFLAGS_SINGLECOPY";
    case TEXTUREFLAGS_PRE_SRGB: return "TEXTUREFLAGS_PRE_SRGB";
    case TEXTUREFLAGS_UNUSED_00100000: return "TEXTUREFLAGS_UNUSED_00100000";
    case TEXTUREFLAGS_UNUSED_00200000: return "TEXTUREFLAGS_UNUSED_00200000";
    case TEXTUREFLAGS_UNUSED_00400000: return "TEXTUREFLAGS_UNUSED_00400000";
    case TEXTUREFLAGS_NODEPTHBUFFER: return "TEXTUREFLAGS_NODEPTHBUFFER";
    case TEXTUREFLAGS_UNUSED_01000000: return "TEXTUREFLAGS_UNUSED_01000000";
    case TEXTUREFLAGS_CLAMPU: return "TEXTUREFLAGS_CLAMPU";
    case TEXTUREFLAGS_VERTEXTEXTURE: return "TEXTUREFLAGS_VERTEXTEXTURE";
    case TEXTUREFLAGS_SSBUMP: return "TEXTUREFLAGS_SSBUMP";
    case TEXTUREFLAGS_UNUSED_10000000: return "TEXTUREFLAGS_UNUSED_10000000";
    case TEXTUREFLAGS_BORDER: return "TEXTUREFLAGS_BORDER";
    case TEXTUREFLAGS_UNUSED_40000000: return "TEXTUREFLAGS_UNUSED_40000000";
    case TEXTUREFLAGS_UNUSED_80000000: return "TEXTUREFLAGS_UNUSED_80000000";
    }

    return "";
}

static std::string flagsToString(uint32_t flags) {
    std::string ret;
    for (int i = 0; i < 32; ++i) {
        std::string part = flagToString(flags & (uint32_t(1) << i));
        if (part.empty()) {
            continue;
        }
        if (!ret.empty()) {
            ret += ", ";
        }
        ret += part;
    }
    return ret;
}

#pragma pack(push, 1)
typedef struct tagVTFHEADER
{
    int32_t     signature;          // File signature ("VTF\0"). (or as little-endian integer, 0x00465456)
    uint32_t    version[2];         // version[0].version[1] (currently 7.2).
    uint32_t    headerSize;         // Size of the header struct  (16 byte aligned; currently 80 bytes) + size of the resources dictionary (7.3+).
    uint16_t    width;              // Width of the largest mipmap in pixels. Must be a power of 2.
    uint16_t    height;             // Height of the largest mipmap in pixels. Must be a power of 2.
    uint32_t    flags;              // VTF flags.
    uint16_t    frames;             // Number of frames, if animated (1 for no animation).
    uint16_t    firstFrame;         // First frame in animation (0 based). Can be -1 in environment maps older than 7.5, meaning there are 7 faces, not 6.
    uint8_t     padding0[4];        // reflectivity padding (16 byte alignment).
    float       reflectivity[3];    // reflectivity vector.
    uint8_t     padding1[4];        // reflectivity padding (8 byte packing).
    float       bumpmapScale;       // Bumpmap scale.
    int32_t     highResImageFormat; // High resolution image format.
    uint8_t     mipmapCount;        // Number of mipmaps.
    int32_t     lowResImageFormat;  // Low resolution image format. This value should always be assumed to be DXT1!
    uint8_t     lowResImageWidth;   // Low resolution image width.
    uint8_t     lowResImageHeight;  // Low resolution image height.

    // 7.2+
    uint16_t    depth;              // Depth of the largest mipmap in pixels. Must be a power of 2. Is 1 for a 2D texture.

    // 7.3+
    uint8_t     padding2[3];        // depth padding (4 byte alignment).
    uint32_t    numResources;       // Number of resources this vtf has. The max appears to be 32.

    uint8_t     padding3[8];        // Necessary on certain compilers
} VTFHEADER;
#pragma pack(pop)

#pragma pack(push, 1)
struct RESOURCE_ENTRY
{
    uint8_t         tag[3]; 		// A three-byte "tag" that identifies what this resource is.
    uint8_t         flags;			// Resource entry flags. The only known flag is 0x2, which indicates that no data chunk corresponds to this resource.
    uint32_t    	offset;			// The offset of this resource's data in the file. 
};
#pragma pack(pop)
static_assert(sizeof(RESOURCE_ENTRY) == 8);

struct DXT1_BLOCK {
    uint16_t color0;
    uint16_t color1;
    uint32_t codes;
};
static_assert(sizeof(DXT1_BLOCK) == 8);

static uint32_t color16to32(uint16_t col) {
    uint32_t ret = 0;
    uint32_t B = (col & 0b11111) << 3;
    uint32_t G = ((col >> 5) & 0b111111) << 2;
    uint32_t R = ((col >> 11) & 0b11111) << 3;
    ret += R;
    ret += G << 8;
    ret += B << 16;
    ret += 0xFF000000; // TODO:
    return ret;
}
static gfxm::vec3 color16toVec3(uint16_t col) {
    gfxm::vec3 ret;
    uint32_t B = col & 0b11111;
    uint32_t G = (col >> 5) & 0b111111;
    uint32_t R = (col >> 11) & 0b11111;
    ret.x = R / 31.f;
    ret.y = G / 63.f;
    ret.z = B / 31.f;
    return ret;
}
static uint32_t colorVec3To32(const gfxm::vec3& col) {
    uint32_t ret = 0;
    ret += uint32_t(0xFF * col.x);
    ret += uint32_t(0xFF * col.y) << 8;
    ret += uint32_t(0xFF * col.z) << 16;
    ret += 0xFF000000;
    return ret;
}
static uint32_t flipBytes(uint32_t v) {
    uint32_t ret = 0;
    ret += (v & 0xFF000000) >> 24;
    ret += (v & 0x00FF0000) >> 8;
    ret += (v & 0x0000FF00) << 8;
    ret += (v & 0x000000FF) << 24;
    return ret;
}
static uint64_t flipBytes(uint64_t v) {
    uint64_t ret = 0;
    ret += (v & 0xFF000000'00000000) >> 56;
    ret += (v & 0x00FF0000'00000000) >> 40;
    ret += (v & 0x0000FF00'00000000) >> 24;
    ret += (v & 0x000000FF'00000000) >> 8;
    ret += (v & 0x00000000'FF000000) << 8;
    ret += (v & 0x00000000'00FF0000) << 24;
    ret += (v & 0x00000000'0000FF00) << 40;
    ret += (v & 0x00000000'000000FF) << 56;
    return ret;
}

#include "stb_image_write.h"

static bool loadDXT1(FILE* f, int width, int height, int hint_mip_level) {
    uint32_t bytes_to_read = (width / 4) * (height / 4) * sizeof(DXT1_BLOCK);
    uint32_t blocks_to_read = bytes_to_read / sizeof(DXT1_BLOCK);
    uint32_t blocks_per_row = width / 4;
    if ((bytes_to_read % sizeof(DXT1_BLOCK)) != 0) {
        LOG_ERR("DXT1_BLOCK size mismatch");
        assert(false);
        return false;
    }

    std::vector<DXT1_BLOCK> blocks(blocks_to_read);
    FREAD(blocks.data(), sizeof(DXT1_BLOCK), blocks_to_read, f);

    std::vector<uint32_t> pixels(width * height);

    for (int i = 0; i < blocks.size(); ++i) {
        const DXT1_BLOCK& block = blocks[i];
        uint32_t block_pixels[16] = { 0 };

        for (int j = 0; j < 16; ++j) {
            uint32_t c = block.codes >> j * 2;
            uint32_t code = (c & 0x02) + (c & 0x01);
            uint32_t color32 = 0;
            gfxm::vec3 fcolor0 = color16toVec3(block.color0);
            gfxm::vec3 fcolor1 = color16toVec3(block.color1);
            switch (code) {
            case 0: color32 = color16to32(block.color0); break;
            case 1: color32 = color16to32(block.color1); break;
            case 2:
                if (block.color0 > block.color1) {
                    color32 = colorVec3To32((2.f * fcolor0 + fcolor1) / 3.f);
                } else {
                    color32 = colorVec3To32((fcolor0 + fcolor1) / 2.f);
                }
                break;
            case 3:
                if (block.color0 > block.color1) {
                    color32 = colorVec3To32((fcolor0 + 2.f * fcolor1) / 3.f);
                } else {
                    color32 = 0xFF000000;
                }
                break;
            default:
                assert(false);
            }

            block_pixels[j] = (color32);
        }
        
        uint32_t col_offset = (i % blocks_per_row) * 4;
        uint32_t row_offset = width * 4 * (i / blocks_per_row);
        memcpy(&pixels[col_offset + row_offset], &block_pixels[0], sizeof(uint32_t) * 4);
        memcpy(&pixels[col_offset + row_offset + width], &block_pixels[4], sizeof(uint32_t) * 4);
        memcpy(&pixels[col_offset + row_offset + width * 2], &block_pixels[8], sizeof(uint32_t) * 4);
        memcpy(&pixels[col_offset + row_offset + width * 3], &block_pixels[12], sizeof(uint32_t) * 4);
    }
    /*
    std::string postfix;
    if (hint_mip_level < 0) {
        postfix = "_thumb";
    } else {
        postfix = MKSTR("_" << hint_mip_level);
    }
    std::string path = MKSTR("experimental/test" << postfix << ".png");
    stbi_flip_vertically_on_write(1);
    stbi_write_png(path.c_str(), width, height, 4, pixels.data(), width * 4);
    */
    return true;
}


#pragma pack(push, 1)
struct DXT5_BLOCK {
    uint8_t alpha0;
    uint8_t alpha1;
    uint8_t alpha_codes[6];
    uint16_t color0;
    uint16_t color1;
    uint32_t codes;
};
#pragma pack(pop)
static_assert(sizeof(DXT5_BLOCK) == 16);

static bool loadDXT5(FILE* f, int width, int height, int hint_mip_level) {
    uint32_t bytes_to_read = (width / 4) * (height / 4) * sizeof(DXT5_BLOCK);
    uint32_t blocks_to_read = bytes_to_read / sizeof(DXT5_BLOCK);
    uint32_t blocks_per_row = width / 4;
    if ((bytes_to_read % sizeof(DXT5_BLOCK)) != 0) {
        LOG_ERR("DXT5_BLOCK size mismatch");
        assert(false);
        return false;
    }

    std::vector<DXT5_BLOCK> blocks(blocks_to_read);
    FREAD(blocks.data(), sizeof(DXT5_BLOCK), blocks_to_read, f);

    std::vector<uint32_t> pixels(width * height);

    for (int i = 0; i < blocks.size(); ++i) {
        const DXT5_BLOCK& block = blocks[i];
        uint32_t block_pixels[16] = { 0 };

        for (int j = 0; j < 16; ++j) {
            uint64_t alpha_codes = 0;
            ((uint8_t*)&alpha_codes)[0] = block.alpha_codes[0];
            ((uint8_t*)&alpha_codes)[1] = block.alpha_codes[1];
            ((uint8_t*)&alpha_codes)[2] = block.alpha_codes[2];
            ((uint8_t*)&alpha_codes)[3] = block.alpha_codes[3];
            ((uint8_t*)&alpha_codes)[4] = block.alpha_codes[4];
            ((uint8_t*)&alpha_codes)[5] = block.alpha_codes[5];

            uint32_t alpha_c = alpha_codes >> j * 3;
            uint32_t color_c = block.codes >> j * 2;
            uint32_t alpha_code = (alpha_c & 0x04) + (alpha_c & 0x02) + (alpha_c & 0x01);
            uint32_t color_code = (color_c & 0x02) + (color_c & 0x01);
            
            float falpha0 = block.alpha0 / 255.f;
            float falpha1 = block.alpha1 / 255.f;
            float falpha = 1.f;
            switch (alpha_code) {
            case 0: falpha = block.alpha0 / 255.f; break;
            case 1: falpha = block.alpha1 / 255.f; break;
            case 2:
                if (block.alpha0 > block.alpha1) {
                    falpha = (6.f * falpha0 + 1.f * falpha1) / 7.f;
                } else {
                    falpha = (4.f * falpha0 + 1.f * falpha1) / 5.f;
                }
                break;
            case 3:
                if (block.alpha0 > block.alpha1) {
                    falpha = (5.f * falpha0 + 2.f * falpha1) / 7.f;
                } else {
                    falpha = (3.f * falpha0 + 2.f * falpha1) / 5.f;
                }
                break;
            case 4:
                if (block.alpha0 > block.alpha1) {
                    falpha = (4.f * falpha0 + 3.f * falpha1) / 7.f;
                } else {
                    falpha = (2.f * falpha0 + 3.f * falpha1) / 5.f;
                }
                break;
            case 5:
                if (block.alpha0 > block.alpha1) {
                    falpha = (3.f * falpha0 + 4.f * falpha1) / 7.f;
                } else {
                    falpha = (1.f * falpha0 + 4.f * falpha1) / 5.f;
                }
                break;
            case 6:
                if (block.alpha0 > block.alpha1) {
                    falpha = (2.f * falpha0 + 5.f * falpha1) / 7.f;
                } else {
                    falpha = .0f;
                }
                break;
            case 7:
                if (block.alpha0 > block.alpha1) {
                    falpha = (1.f * falpha0 + 6.f * falpha1) / 7.f;
                } else {
                    falpha = 1.f;
                }
                break;
            default:
                assert(false);
            }

            uint32_t color32 = 0;
            gfxm::vec3 fcolor0 = color16toVec3(block.color0);
            gfxm::vec3 fcolor1 = color16toVec3(block.color1);
            switch (color_code) {
            case 0: color32 = color16to32(block.color0); break;
            case 1: color32 = color16to32(block.color1); break;
            case 2:
                if (block.color0 > block.color1) {
                    color32 = colorVec3To32((2.f * fcolor0 + fcolor1) / 3.f);
                } else {
                    color32 = colorVec3To32((fcolor0 + fcolor1) / 2.f);
                }
                break;
            case 3:
                if (block.color0 > block.color1) {
                    color32 = colorVec3To32((fcolor0 + 2.f * fcolor1) / 3.f);
                } else {
                    color32 = 0xFF000000;
                }
                break;
            default:
                assert(false);
            }

            color32 =
                (color32 & 0x00FFFFFF)
                + (uint32_t(falpha * 255.f) << 24);

            block_pixels[j] = (color32);
        }

        uint32_t col_offset = (i % blocks_per_row) * 4;
        uint32_t row_offset = width * 4 * (i / blocks_per_row);
        memcpy(&pixels[col_offset + row_offset], &block_pixels[0], sizeof(uint32_t) * 4);
        memcpy(&pixels[col_offset + row_offset + width], &block_pixels[4], sizeof(uint32_t) * 4);
        memcpy(&pixels[col_offset + row_offset + width * 2], &block_pixels[8], sizeof(uint32_t) * 4);
        memcpy(&pixels[col_offset + row_offset + width * 3], &block_pixels[12], sizeof(uint32_t) * 4);
    }
    /*
    std::string postfix;
    if (hint_mip_level < 0) {
        postfix = "_thumb";
    } else {
        postfix = MKSTR("_" << hint_mip_level);
    }
    std::string path = MKSTR("experimental/dxt5" << postfix << ".png");
    stbi_flip_vertically_on_write(1);
    stbi_write_png(path.c_str(), width, height, 4, pixels.data(), width * 4);
    */
    return true;
}

static bool loadHiResImageData(
    FILE* f,
    int width,
    int height,
    uint32_t flags,
    IMAGE_FORMAT fmt,
    int mip_count,
    int frame_count,
    gpuTexture2d* texture
) {
    if(fmt == IMAGE_FORMAT_DXT1) {
        for (int imip = 0; imip < mip_count; ++imip) {
            int mip_level = (mip_count - 1 - imip);
            int w = std::max(1, width >> mip_level);
            int h = std::max(1, height >> mip_level);

            uint32_t byte_count = ((w < 4 ? 4 : w) / 4) * ((h < 4 ? 4 : h) / 4) * sizeof(DXT1_BLOCK);
            for (int iframe = 0; iframe < frame_count; ++iframe) {
                std::vector<uint8_t> bytes(byte_count);
                fread(bytes.data(), byte_count, 1, f);

                texture->setDataDXT1RGBA(bytes.data(), mip_level, w, h, byte_count);
                /*
                if(flags & TEXTUREFLAGS_EIGHTBITALPHA) {
                    texture->setDataDXT1RGBA(bytes.data(), mip_level, w, h, byte_count);
                } else {
                    texture->setDataDXT1RGB(bytes.data(), mip_level, w, h, byte_count);
                }*/
                //loadDXT1(f, w, h, mip_level);
            }
        }
        texture->setFilter(GPU_TEXTURE_FILTER_MIPMAP_LINEAR);
    } else if (fmt == IMAGE_FORMAT_DXT5) {
        for (int imip = 0; imip < mip_count; ++imip) {
            int mip_level = (mip_count - 1 - imip);
            int w = std::max(1, width >> mip_level);
            int h = std::max(1, height >> mip_level);

            uint32_t byte_count = ((w < 4 ? 4 : w) / 4) * ((h < 4 ? 4 : h) / 4) * sizeof(DXT5_BLOCK);
            for (int iframe = 0; iframe < frame_count; ++iframe) {
                std::vector<uint8_t> bytes(byte_count);
                fread(bytes.data(), byte_count, 1, f);
                texture->setDataDXT5(bytes.data(), mip_level, w, h, byte_count);
                //loadDXT5(f, w, h, mip_level);
            }
        }
        texture->setFilter(GPU_TEXTURE_FILTER_MIPMAP_LINEAR);
    } else {
        LOG_ERR("Unsupported high res format: " << imageFormatToString(fmt));
        assert(false);
        return true;
    }

    return true;
}

bool hl2LoadTexture7_1(const VTFHEADER& head, FILE* f, gpuTexture2d* texture) {
    loadDXT1(f, head.lowResImageWidth, head.lowResImageHeight, -1);
    // TODO: Handle padding for non-power-of-two textures
    
    loadHiResImageData(
        f,
        head.width,
        head.height,
        head.flags,
        (IMAGE_FORMAT)head.highResImageFormat,
        head.mipmapCount,
        head.frames,
        texture
    );

    return true;
}
bool hl2LoadTexture7_2(const VTFHEADER& head, FILE* f, gpuTexture2d* texture) {
    // TODO:
    /*
    
    * 7.2

    Added volumetric texture support.
    Released September 23rd, 2005 as a Steam engine update and supported in later versions of Source 2004.
    
    */
    return hl2LoadTexture7_1(head, f, texture);
}

#define RESOURCE_ENTRY_TAG_LO_RES (0x000001)
#define RESOURCE_ENTRY_TAG_HI_RES (0x000030)

bool hl2LoadTexture7_3(const VTFHEADER& head, FILE* f, gpuTexture2d* texture) {
    std::unordered_map<uint32_t, RESOURCE_ENTRY> entries;

    for (int i = 0; i < head.numResources; ++i) {
        RESOURCE_ENTRY entry = { 0 };
        FREAD(&entry, sizeof(entry), 1, f);
        
        uint32_t tag = 0;
        tag += entry.tag[0];
        tag += entry.tag[1] << 8;
        tag += entry.tag[2] << 16;
        entries[tag] = entry;
        LOG_DBG("tag: " << std::hex << "0x" << tag);
    }

    {
        auto it = entries.find(RESOURCE_ENTRY_TAG_LO_RES);
        if (it == entries.end()) {
            LOG_ERR("No low res texture resource entry");
            //assert(false);
            return false;
        }

        fseek(f, it->second.offset, SEEK_SET);
        loadDXT1(f, head.lowResImageWidth, head.lowResImageHeight, -1);
    }

    {
        auto it = entries.find(RESOURCE_ENTRY_TAG_HI_RES);
        if (it == entries.end()) {
            LOG_ERR("No hi res texture resource entry");
            assert(false);
            return false;
        }

        fseek(f, it->second.offset, SEEK_SET);
        loadHiResImageData(
            f,
            head.width,
            head.height,
            head.flags,
            (IMAGE_FORMAT)head.highResImageFormat,
            head.mipmapCount,
            head.frames,
            texture
        );
    }

    return true;
}

bool hl2LoadTextureFromFile(FILE* f, RHSHARED<gpuTexture2d>& texture) {
    uint64_t file_offset = ftell(f);

    VTFHEADER head = { 0 };
    FREAD(&head, sizeof(head), 1, f);
    if (head.signature != IDVTFHEADER_LE && head.signature != IDVTFHEADER_BE) {
        //LOG_ERR("VTF file header mismatch: " << path);
        assert(false);
        return false;
    }
    bool is_big_endian = false;
    if (head.signature == IDVTFHEADER_BE) {
        is_big_endian = true;
        // TODO: Not supported, remove assert if implemented
        assert(false);
    }

    LOG("VTF VERSION: " << head.version[0] << "." << head.version[1]);
    /*LOG("WIDTH: " << head.width << ", HEIGHT: " << head.height);
    LOG("LORES WIDTH: " << int32_t(head.lowResImageWidth) << ", LORES HEIGHT: " << int32_t(head.lowResImageHeight));
    LOG("NUM FRAMES: " << head.frames);
    LOG("LOW RES FMT: " << imageFormatToString((IMAGE_FORMAT)head.lowResImageFormat));
    LOG("HIGH RES FMT: " << imageFormatToString((IMAGE_FORMAT)head.highResImageFormat));
    LOG("FLAGS: " << flagsToString(head.flags));*/

    if(head.version[0] == 7 && head.version[1] < 3) {
        fseek(f, file_offset + head.headerSize, SEEK_SET);
    }

    texture.reset_acquire();

    uint64_t ver = uint64_t(head.version[0]) + (uint64_t(head.version[1]) << 32);
    switch (ver) {
    case VTF_VERSION_7_1:
        if (!hl2LoadTexture7_1(head, f, texture.get())) {
            return false;
        }
        break;
    case VTF_VERSION_7_2:
        if(!hl2LoadTexture7_2(head, f, texture.get())) {
            return false;
        }
        break;
    case VTF_VERSION_7_3:
        if(!hl2LoadTexture7_3(head, f, texture.get())) {
            return false;
        }
        break;
    case VTF_VERSION_7_4:
        if(!hl2LoadTexture7_3(head, f, texture.get())) {
            return false;
        }
        break;
    default:
        LOG_ERR("Unknown VTF version: " << head.version[0] << "." << head.version[1]);
        assert(false);
        return false;
    }

    /*
    // TODO:
    {
        const int w = 2;
        const int h = 2;
        uint32_t data[w * h] = {
            0xFF0000FF, 0xFF00FF00,
            0xFFFF0000, 0xFFFF00FF
        };
        texture.reset_acquire();
        texture->setData(data, 2, 2, 4, IMAGE_CHANNEL_UNSIGNED_BYTE, false);
    }*/
    return true;
}

bool hl2LoadTextureImpl(const char* path, RHSHARED<gpuTexture2d>& texture) {
    LOG("Loading VTF: '" << path << "'");

    bool is_big_endian = false;

    if (!path) {
        LOG_ERR("VTF file path is null");
        assert(false);
        return false;
    }

    FILE* f = fopen(path, "rb");
    if (!f) {
        LOG_ERR("Failed to open VTF file: " << path);
        assert(false);
        return false;
    }

    if (!hl2LoadTextureFromFile(f, texture)) {
        fclose(f);
        return false;
    }
    
    fclose(f);
    return true;
}


#include <map>
static std::map<std::string, RHSHARED<gpuTexture2d>> s_textures;
bool hl2LoadTexture(const char* path, RHSHARED<gpuTexture2d>& texture) {
    auto it = s_textures.find(path);
    if (it != s_textures.end()) {
        texture = it->second;
        return true;
    }
    
    if (!hl2LoadTextureImpl(path, texture)) {
        texture = resGet<gpuTexture2d>("core/textures/error_yellow.png");
        s_textures[path] = texture;
        return false;
    }

    s_textures[path] = texture;
    return true;
}

void hl2StoreTexture(const char* path, const RHSHARED<gpuTexture2d>& texture) {
    std::string path_ = path;
    for(int i = 0; i < path_.size(); ++i) {
        path_[i] = std::tolower(path_[i]);
    }
    s_textures[path_] = texture;
}